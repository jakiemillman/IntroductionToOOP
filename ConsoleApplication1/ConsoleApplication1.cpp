//IntroductionToOOP
#include <iostream>
using namespace std;
//Создавая структуру или класс, мы создаем новый типа данных, который является сложным в отличае от приметивных, таких как int, double, char;
//Классы и структуры называют пользовательскими типами данных;
//Объекты называют экземплярами (instance);
class Point
{
    double x;
    double y;
public:
    //Methods
    double get_x()const
    {
        return x;
    }
    double get_y()const
    {
        return y;
    }
    void set_x(double x)
    {
        this->x = x;
    }
    void set_y(double y)
    {
        this->y = y;
    }
    double distace(Point& B)
    {
        return sqrt((x - B.get_x()) * (x - B.get_x()) + (y - B.get_y()) * (y - B.get_y()));
    }
    void Print()
    {
        cout << "x = " << x << "\t" << "y = " << y<<endl;
    }

    //Constructors:
    /*Point()
    {
        x = y = 0;
        cout << "Constructor:\t" << this << endl;
    }*/
    /*Point(double x)
    {
        this->x = x;
        y = 0;
        cout << "1ArgConstructor:\t" << endl;
    }*/
    Point(const Point& other)
    {
        this->x = other.x;
        this->y = other.y;
        cout << "CopyConstructor:" << this << endl;
    }
    Point(double x=0, double y=0)
    {
        this->x = x;
        this->y = y;
        cout << "Constructor:\t" << this << endl;
    }
    ~Point()
    {
        cout << "Destructor:\t" << this << endl;
    }
    //Operators
    Point& operator=(const Point& other)
    {
        this->x = other.x;
        this->y = other.y;
        cout << "CopyAssingment:" << this << endl;
        return *this;
    }
};
double Distance(const Point& A,const Point& B)
{
    return sqrt((A.get_x()-B.get_x())* (A.get_x() - B.get_x()) + (A.get_y() - B.get_y()) * (A.get_y() - B.get_y()));
}


//#define STRUCT_POINT
//#define distance_chek
//#define constructors_chek
//#define AssingmentOperators
#define delimiter "-----------------------------------------------------------\n"

int main()
{
    setlocale(LC_ALL, "rus");
#ifdef STRUCT_POINT



    //members
    int a;//объявление переменной 'a' типа 'int'
    Point A;//объявление переменной 'A' типа 'Point'
            //объявление объекта 'A' типа 'Point'
            //объявление объекта 'A' типа 'Point'
    A.x = 2;
    A.y = 3;
    cout << A.x << " " << A.y << endl;
    Point* pA = &A;
    cout << pA->x << " " << pA->y << endl;
#endif // STRUCT_POINT
#ifdef distance_chek
    Point A;
    Point B;
    A.set_x(10);
    A.set_y(10);
    B.set_x(21);
    B.set_y(21);
    //cout << A.get_x() << "\t" << A.get_y() << endl;
    A.Print();
    cout<<delimiter;
    B.Print();
    cout << A.distace(B)<<endl;

    cout << Distance(A, B)<<endl;
#endif
    
#ifdef constructors_chek
    Point A; //Defaul constructor
    A.Print();
    Point B = 5;
    B.Print();
    Point C(2, 3);
    C.Print();
    Point D = C;
    D.Print();

    Point E;
    E = D;
    E.Print();
#endif
#ifdef AssingmentOperators



    int a, b, c;
    a = b = c = 0;
    cout << a << "\t" << b << "\t" << c << "\t" << endl;
    Point A, B, C;
    cout << delimiter << endl;
    A = B = C = Point(2, 3);
    cout << delimiter << endl;

    A.Print();
    B.Print();
    C.Print();
#endif // 
    /*1. Инкапсуляция - это сокрытие определенной части класса от внешнего мира.
            модификаторы доступа: 
      2. Prtivate - закрытые поля, доступные только внутри класса и не доступны за его пределами.
            В этой секции обычно размещаются переменные класса, это защищает их от случайной перезаписи.
            Public - это открытые поля, доступные из любого места программы. Здесь обычно размещают методы, и здесь ни в коем случае нельзя размещать переменные члены класса. 
            Protected - доступны только внутри класса и его дочерних классов. Этот модификатор доступа используется только при наследовании.
            Отличие класса от структуры в том, что в структуре все поля по умолчанию открыты, а в классе закрыты.
      Get-Set методы нужны для получения доступа к закрытым переменным в классе.
            get (взять) - открывает достуб к закрытым полям на чтение, т. е. позволяет взять или получить значение к закрытой переменной.
            set (задать, установить) - открывает доступ к закрытым переменным на запись, т. е., позваляет задавать значение закрытых переменных.
            кроме того srt-методы обеспечивают фильтрацию данных, т.е. предотвращают попадание некорректных значаний в переменные значения класса.
            get и set метод должен быть у каждой переменной в классе, т.е get и set методов в классе будет ровно столько, сколько и переменных в классе
            
            get методы обязательно должны быть константными. Константным назывется метод, который не изменяет объект для которого вызывается.
            
            This - это указатель на объект, для которого вызывается метод.

    1. Constructor - метод, который создает объект. Он выделяет память под объект, и инициализирует его поля при создании. Как и любую другую функцию можно перегрузить, потому что его можно перегрузить.В классе может быть сколько угодно конструкторов.
    2. ~Distructor - это метод, который уничтожает объект по завершении его времени жизни. Время жизни объекта завершается при выходе за пределы области видимости, к которой он объявлен. Конструктор и деструктор никогда не возвращают никаких значений, при это перед ними даже не пишется ключевое слово void.
    Никогда не принимает никаких параментров, поэтому и перегрузить его нелья. Может быть только 1 деструктор. Не важно каким образом создавались объекты, все объекты удаляются одинаково.
    3. Assingment operator

    Кострукторы бывают с параметрами, без параметров, по умолчанию, конструктор копирования, коструктор переноса.

    Коструктор по умолчания(default constructor):
        - это конструктор, который может быть вызван без параметров. Это может быть конструктор, не принимающий никаких параметров, или же конструктор, каждый параметр которого имеет значение по умолчанию.
        Конструктор по умолчанию всякий раз неявно вызывается, когда мы просто создаём объект, и не знаем каким он будет. В таком случае вызывается объект по умолчанию, и создает объект по умолчанию.

        Конструктор по умолчанию может быть неявным, т.е. если в классе нет ни одного конструктора, то компилятор неявно добавит туда конструктор по умолчанию, такой неявный конструктор по умолчанию,
        просто выделяет память под объект, и инициализирует его поля мусором. Если в классе написать один конструктор, то неявный конструктор по умолчанию сразу же удаляется из класса.
        
        Если мы хотим определять каким будет наш объект при создании, нам нужен будем параметризованный конструктор, т.е. конструктор который принимает параметры.

        Конструктор копирования - конструктор, который копирует объект, а именно создоваеммый объект делает точной копией существующего объекта.
    Конструктор копирования критически важен, если в классе используется динамическая память, в таком случае он выполняет так называемые бит копии, или же побитовое копирование.
    А именно при создании объекта выделяет новую область динамической памяти, и копирует её содержимое из другого объекта. Конструктор копирования может быть неявным, т.е. если мы его не напишем, то компилятор сам его добавит.
    Но неявный конструктор копирования выполняет так называемое шеллоу копи, т.е. поверхностное копирование. Он не понимает что нужно выделить новую память, и скопировать её содержимое.
    Неявный конструктор копирования, просто копирует все переменные из одного объекта в другой, если переменная является указателем, то просто копируется адрес из одного указателя в другой. И таким образом
    мы получаем 2 объекта владеющих одной областью динамической памяти. Что как правило приводит к аварийному завершению программы, 
    поэтому конструктор копирования кретически необходим при использовании динамической памяти. Но если в классе нет динамической памяти, то он необязателен. И можно пользоваться неявным конструктором копирования.
        
        Конструктор копирования всегда принимает константную ссилку на объект

        Оператор присваивания(Assingment operator). Любой конструктор для конкретного объекта может быть вызван только 1 раз(для создания этого объекта). Когда объект уже создан, для него нельзя вызвать конструктор.
    В частности если мы хотим существующий объект сделать точно копией другого существующего объекта, то конструктор копирования вызвать не получится. Для этих целей в классе должен быть оператор присваивания.
    Он делает тоже самое что и конструктор копирования, но для существующего объекта. Оператор присваивания, так же как и конструктор копирования критически важен в классе при использовании динамической памяти, 
    он так же как и конструктор копирования выполняет дип копи или побитовое копирование.
        Мы много говорили о том, как передать параметры в функцию, их можно передать по значению либо по указателю, либо по ссылке, но мы ни разу не говорили о том, 
    как функция может возвращать значение. Значение из функции так же может возвращаться по значению, по указателю, либо по ссылке. И если функция возвращает значение по значению, 
    то возвращаемое значение копируется на место вызова, и если возвращаемое значение объект, то для него вызывается конструктор копирования. Чтобы возвращаемое значение не копировалось на место вызова, 
    его нужно вернуть по указателю, либо по ссылке. В случае с объектами это может сэкономить ресурсы памяти и процессорного времени. Но слудет учитывать то, что если на место вызова возвращается локальный объект, то его не в коем случае нельзя возвращать по ссылке
    или у казателю, посколько все локальные объекты удаляются из функции по её завершению. Когда значение возвращается из функции по значению на месте вызова функции неявно создвется временный безимянный объект.
    Временные безымянные объекты - это константы, которые существуют в пределах одного выражения, а не удаляются из памяти по завершении этого выражения.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        ПЕРЕГРУЗКА ОПЕРАТОРОВ!!!!!!!!!!!!!!!!!!!!!!

        Перегрузка операторов нужна для более удобной работы с объектами. Благодаря перегрузке операторов над объектами можно выполнять такие же действия, как и над обычными переменными (+,-,== и т.д.).
    
    Правила перегрузки операторов:
    1. Перегрузить можно только существующие операторы.
        Наример:
         + - перегружается;
         ++ - перегружается;
         * - перегружается;
         ** - не перегружается;
    2. Не все существующие операторы можно перегрузить:
        Не перегружается:
        ?: - тернарный оператор
        :: - оператор разрешения видимости
        . - оператор прямого доступа
        .* - Pointer to member selection
        #
        ##;
    3. Перегруженные операторы сохраняют приоритет.
    4. Переопределить поведение операторов над встроенными типами невозможно;

        Перегруженные операторы - это самые обфычные функции, имя которых состоит из ключевого слова оператор и знака оператора.
    Операторы можно перегружать как в классе, так и за классом. И если оператор перегружен в классе, то он является методом, п метод может быть вызван только для какого-то объекта.
    Если унарный оператор перегружен в классе, то он никогда не принимает никаких параметров. А его единственным операндом будет объект для которого он вызывается. 
    Если унарный оператор перегружен за классом, то он в обязательном порядке принимает только 1 параметр.
    Если бинарный оператор перегружен в классе, то он ва обязательном порядке принимает только 1 параметр, твой операнд справа. Его операндом слева является объект для которого он вызывается, 
    к нему всегда можно получить доступ через this.
    Если бинарный оператор перегружается за классом, то он в обязательном порядке принимает 2 параметра (свои операнды);
    При перегрузке операторов следует учитывать, что некоторые операторы изменяют свои операнды, а некоторые нет. Те операторы которые изменяют свои операнды, лучше перегрузить в классе.
    Операторы, которые не изменяют свои операнды, лучше изменять за классом.

    -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
            */
}